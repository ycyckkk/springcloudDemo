##微服务
举例：单体应用中，当某个模块产生问题，会影响整个系统，导致服务瘫痪（隔离）。
目的：将系统进行微服务化后，提升系统可用性，扩展性， 维护性。

### 高可用
- 应用的高可用:均衡负载&失效转移，应用or接口限流，请求重试&接口幂等，服务熔断&及时降级&故障恢复，应用监控&健康检查

- 中间件高可用:
  -  Redis:主备，集群，哨兵
  -  Kafka:一个topic对应多个partition，每个partition在不同的broker上，每个broker有独立的副本，然后leader宕机会主动切换
  -  ElasticSearch:
  -  Zookeeper:
  -  Nginx:

- 数据库高可用:高效的索引，数据库的冷热分离等

#### 限流：

给系统设置的保护措施，在高并发场景下，设置一个最大请求数量，当超过该值时，系统采取相应策略（wiki）

限流类型：接口限流，应用限流，数据库限流

限流算法：计数器，技术队列，漏洞，令牌桶，动态调整

限流策略：拒绝响应，服务降级，特权请求，延时处理，弹性伸缩

限流目的：
- 系统的可用性，能及时响应用户请求
- 多个租户下的资源隔离
- 应对突发的流量
- 节约使用的成本

设计方案：
- 需要尽量在早期规划（**设计**）
- 及时给出响应（**性能**）
- 手动开关（**运维**）
- 响应特定的码，走监控事件通知，反馈给上游运维人员（**通知**），运维能进行扩容
- 响应客户端，客户端能辨别异常原因，这样方便进行重试等（**上游重试**）
- 通过在请求头中，加入内容已响应给后端服务（**下游降级**）

**难点：**动态调整，给每个API进行限流

**结合项目：**

实现方式：

- zuul（过滤器）+redis（引入）
- aop+自定义注解+redis+lua脚本

#### 重试

#### 幂等
在高并发场景下，防止网络错误或者是消息重复消费，导致生成重复数据和错误数据

解决方法：通过redis进行幂等，更新时key为业务id，或者业务id+时间戳（年月日时分秒格式），然后设置极短的超时时间


#### 熔断
概念：
应用A->应用B->应用C，此时应用C故障，应用B返回错误，应用A可能一直进行重试,造成系统资源浪费
熔断器可以中断程序不断重试，可能导致失败的操作，防止失败请求耗尽系统的计算和网络资源。错误修正后，可以让程序正常响应。

状态：闭合->断开->半开
- 闭合：程序正常运行；
- 记录失败的计数器，时间间隔，失败阈值
- 断开：程序停止响应，立即返回错误（或将错误记录到缓存中），达到服务降级的效果（差异化降级，多租户的场景下）
- 熔断的时间；
- 半开，服务恢复的过程
- 记录成功的计数器，时间间隔，成功阈值
- 闭合：

#### 降级
概念：当请求超时后，超过熔断器预设的阈值。此时熔断器会断开

###扩展性
主备，集群，哨兵，leader选举，数据副本备份

###维护性

