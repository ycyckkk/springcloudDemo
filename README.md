##微服务
举例：单体应用中，当某个模块产生问题，会影响整个系统，导致服务瘫痪（隔离）。
目的：将系统进行微服务化后，提升系统可用性，扩展性， 维护性。

### 高可用

#### 限流：

给系统设置的保护措施，在高并发场景下，设置一个最大请求数量，当超过该值时，系统采取相应策略（wiki）

限流类型：接口限流，应用限流，数据库限流

限流算法：计数器，技术队列，漏洞，令牌桶，动态调整

限流策略：拒绝响应，服务降级，特权请求，延时处理，弹性伸缩

限流目的：
- 系统的可用性，能及时响应用户请求
- 多个租户下的资源隔离
- 应对突发的流量
- 节约使用的成本

设计方案：
- 需要尽量在早期规划（**设计**）
- 及时给出响应（**性能**）
- 手动开关（**运维**）
- 响应特定的码，走监控事件通知，反馈给上游运维人员（**通知**），运维能进行扩容
- 响应客户端，客户端能辨别异常原因，这样方便进行重试等（**上游重试**）
- 通过在请求头中，加入内容已响应给后端服务（**下游降级**）

**难点：**动态调整，给每个API进行限流

**结合项目：**

实现方式：

- zuul（过滤器）+redis（引入）
- aop+自定义注解+redis+lua脚本

#### 重试

#### 幂等



#### 熔断
概念：
应用A->应用B->应用C，此时应用C故障，应用B返回错误，应用A可能一直进行重试,造成系统资源浪费
熔断器可以中断程序不断重试，可能导致失败的操作，防止失败请求耗尽系统的计算和网络资源。错误修正后，可以让程序正常响应。

状态：闭合->断开->半开
- 闭合：程序正常运行；
- 记录失败的计数器，时间间隔，失败阈值
- 断开：程序停止响应，立即返回错误（或将错误记录到缓存中）
- 熔断的时间；
- 半开：
- 记录成功的计数器，时间间隔，成功阈值
- 闭合：

#### 降级

###扩展性

###维护性